#include <SPI.h>
#include <nRF24L01.h>
#include <RF24.h>
const byte addr[] = "1Node";
const byte pipe = 1;  // 指定通道編號
RF24 RF(2,3);//ce,csn

struct Signal{
  byte thro;
  byte rudd;
  byte elev;
  byte aile;};
  
Signal data;  

int signal1 = 0;
int signal2 = 0;
int signal3 = 0;
int signal4 = 0;

int m1 = 9; //馬達1訊號1
int m2 = 10;//馬達1訊號2
int m3 = 5; //馬達2訊號1
int m4 = 6; //馬達2訊號2

void Reset(){
  data.thro = 127;//斷線及沒連線時的動作
  data.rudd = 127;
  data.elev = 127;
  data.aile = 127;}
   
void setup() {
  Serial.begin(9600);
  pinMode(m1,OUTPUT);//腳位設定為輸出
  pinMode(m2,OUTPUT);//腳位設定為輸出
  pinMode(m3,OUTPUT);//腳位設定為輸出
  pinMode(m4,OUTPUT);//腳位設定為輸出
  
  Reset();                        //重整
  RF.begin();                     //開啟無線模組
  RF.setChannel(83);              //設定頻道編號
  RF.openReadingPipe(pipe,addr);  //設定通道地址
  RF.setPALevel(RF24_PA_MIN);     //設定功率
  RF.setDataRate(RF24_250KBPS);   //設定速率
  RF.startListening();            //開始接收
}
unsigned long lastRecvTime = 0;   //宣告一個時間變數

void recvData()
{
while ( RF.available() ) {
RF.read(&data, sizeof(Signal));
lastRecvTime = millis();   //接收
}
}

void loop() {
 int sp1,sp2;
 
 recvData();//接收訊號signal1~4
unsigned long now = millis();
if ( now - lastRecvTime > 1000 ) {
Reset(); // 超過一秒沒訊號就斷線，回到原本設置的動作上
}

signal1=map(data.thro,0,255,500,2500);//把原本發射端訊號值0~255放大為500~2500
signal2=map(data.rudd,0,255,500,2500);
signal3=map(data.elev,0,255,500,2500);
signal4=map(data.aile,0,255,500,2500);

if(signal1<1550&&signal1>1450&&signal2>1450&&signal2<1550){
  Serial.println("STOP");
  digitalWrite(m1,0);
  digitalWrite(m2,0);
  digitalWrite(m3,0);
  digitalWrite(m4,0);}
  
else if(signal1>1550&&signal2>1450&&signal2<1550){
  sp1= (signal1-1550)/3.7;
  if(sp1>255)sp1=255;
  Serial.println("Forward");
  analogWrite(m1,0);
  analogWrite(m2,sp1);
  analogWrite(m3,0);
  analogWrite(m4,sp1);}
  
else if(signal1<1450&&signal2>1450&&signal2<1550){
    sp1= (1450-signal1)/3.7;
    if(sp1>255)sp1=255;
  Serial.println("Backward");
  analogWrite(m1,sp1);
  analogWrite(m2,0);
  analogWrite(m3,sp1);
  analogWrite(m4,0);}

else if(signal1<1550&&signal1>1450&&signal2>1550){
  sp1= (signal2-1550)/4.75;
    if(sp1>200)sp1=200;
  analogWrite(m1,0);
  analogWrite(m2,sp1);
  analogWrite(m3,sp1);
  analogWrite(m4,0);

}
else if(signal1<1550&&signal1>1450&&signal2<1450){
  sp1= (1450-signal2)/4.75;
  if(sp1>200)sp1=200;
  analogWrite(m1,sp1);
  analogWrite(m2,0);
  analogWrite(m3,0);
  analogWrite(m4,sp1);

}
else if(signal1>1550&&signal2>1550){
  Serial.println("Forward LEFT");
  digitalWrite(m1,0);
  digitalWrite(m2,1);
  digitalWrite(m3,0);
  digitalWrite(m4,0);}

else if(signal1>1550&&signal2<1450){
  Serial.println("Forward RIGHT");
  digitalWrite(m1,0);
  digitalWrite(m2,0);
  digitalWrite(m3,0);
  digitalWrite(m4,1);}  
  
else if(signal1<1450&&signal2>1550){
  Serial.println("Backward LEFT");
  digitalWrite(m1,1);
  digitalWrite(m2,0);
  digitalWrite(m3,0);
  digitalWrite(m4,0);}
      
else if(signal1<1450&&signal2<1450){
  Serial.println("Backward RIGHT");
  digitalWrite(m1,0);
  digitalWrite(m2,0);
  digitalWrite(m3,1);
  digitalWrite(m4,0);} 
}